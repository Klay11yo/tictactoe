<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sudoku — Single Player</title>
<style>
  :root{
    --bg:#f6f7fb;
    --card:#ffffff;
    --accent:#1f6feb;
    --muted:#64748b;
    --cell-size: min(9.5vw,56px);
  }
  *{box-sizing:border-box}
  body{
    margin:0;
    font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background:linear-gradient(180deg,#f8fafc,#eef2ff);
    color:#0f172a;
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:100vh;
    padding:20px;
  }
  .wrap{
    width:100%;
    max-width:1100px;
    display:flex;
    gap:20px;
    align-items:flex-start;
  }
  .panel{
    background:var(--card);
    border-radius:12px;
    padding:16px;
    box-shadow: 0 6px 20px rgba(15,23,42,0.06);
  }
  .left{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  h1{margin:0;font-size:1.05rem}
  .board{
    display:grid;
    grid-template-columns: repeat(9, var(--cell-size));
    grid-template-rows: repeat(9, var(--cell-size));
    gap:4px;
    padding:8px;
    background:linear-gradient(180deg,#fff,#fbfdff);
    border-radius:8px;
  }
  .cell{
    background:white;
    border-radius:6px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:600;
    font-size:1.1rem;
    color:#0b1220;
    position:relative;
    user-select:none;
    cursor:pointer;
    outline:0;
  }
  .cell.given{background:linear-gradient(180deg,#f3f6ff,#eef4ff); color:#0b1220; cursor:default;}
  .cell.selected{box-shadow:0 0 0 3px rgba(31,111,235,0.12);}
  .cell.same-row-col-box{background:linear-gradient(90deg, rgba(31,111,235,0.03), transparent);}
  .cell.conflict{background:linear-gradient(90deg, rgba(239,68,68,0.08), transparent);}

  /* Thicker borders for 3x3 blocks */
  .cell:nth-child(3n){ border-right: 4px solid rgba(15,23,42,0.06); }
  .cell:nth-child(n+19):nth-child(-n+27),
  .cell:nth-child(n+46):nth-child(-n+54),
  .cell:nth-child(n+73):nth-child(-n+81) { /* not used; fallback handled with grid-area logic below */ }

  /* We will add specific border style using inline style calculation for exact block edges */
  .cell .value{font-size:1.1rem}
  .pencil{
    position:absolute;
    inset:6px;
    display:grid;
    grid-template-columns:repeat(3,1fr);
    grid-template-rows:repeat(3,1fr);
    gap:2px;
    font-size:10px;
    color:#475569;
    font-weight:500;
    align-items:center;
    justify-items:center;
    opacity:0.9;
    pointer-events:none;
  }
  .controls{
    display:flex;
    gap:8px;
    align-items:center;
    flex-wrap:wrap;
  }
  button, select{
    padding:8px 10px;
    border-radius:8px;
    border:1px solid rgba(15,23,42,0.08);
    background:#fff;
    cursor:pointer;
    font-weight:600;
  }
  button.primary{
    background:linear-gradient(180deg,var(--accent),#155ecf);
    color:white;
    border:0;
  }
  .sidebar{
    width:320px;
    min-width:220px;
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .kbd{
    display:flex;
    gap:6px;
    flex-wrap:wrap;
  }
  .key{
    background:#f8fafc;
    border:1px solid #e6eefb;
    border-radius:6px;
    padding:8px 10px;
    font-weight:700;
    color:#0f172a;
  }
  .meta{
    color:var(--muted);
    font-size:0.9rem;
  }
  .footer{
    display:flex;
    justify-content:space-between;
    gap:8px;
    align-items:center;
  }
  .status{font-weight:700;color:#0f172a}
  @media (max-width:980px){
    .wrap{flex-direction:column;align-items:center}
    .sidebar{width:100%;max-width:640px}
  }
</style>
</head>
<body>
<div class="wrap">
  <div class="panel left" style="flex:1">
    <div style="display:flex;align-items:center;justify-content:space-between;gap:12px">
      <div>
        <h1>Sudoku — Single Player</h1>
        <div class="meta">Play, pencil in candidates, get hints, and save progress locally.</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center">
        <select id="preset">
          <option value="default">Default puzzle</option>
          <option value="easy">Easy example</option>
          <option value="medium">Medium example</option>
          <option value="hard">Hard example</option>
        </select>
        <button id="restart" title="Restart puzzle">Restart</button>
        <button id="undo">Undo</button>
      </div>
    </div>

    <div id="board" class="board" aria-label="Sudoku board" tabindex="0" style="margin-top:12px">
      <!-- 81 cells inserted by script -->
    </div>

    <div style="display:flex;align-items:center;justify-content:space-between;margin-top:12px">
      <div class="controls">
        <button id="togglePencil">Pencil: Off</button>
        <button id="hint">Hint</button>
        <button id="check">Validate</button>
        <button id="clear">Clear</button>
        <button id="download">Download</button>
        <input id="uploadFile" type="file" accept=".txt" style="display:none">
        <button id="upload">Upload</button>
      </div>
      <div class="meta" id="progress">Filled: 0 / 81</div>
    </div>
  </div>

  <aside class="panel sidebar">
    <div>
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div style="font-weight:700">Controls</div>
        <div class="status" id="statusLabel">Ready</div>
      </div>
      <div style="margin-top:8px" class="kbd">
        <div class="key">1–9</div><div class="meta">Type number to enter</div>
        <div class="key">Backspace / Delete</div><div class="meta">Clear cell</div>
        <div class="key">P</div><div class="meta">Toggle pencil mode</div>
        <div class="key">H</div><div class="meta">Hint</div>
        <div class="key">Ctrl+Z</div><div class="meta">Undo</div>
      </div>
    </div>

    <div>
      <div style="font-weight:700;margin-bottom:6px">Notes</div>
      <div class="meta">This game stores your progress in your browser (localStorage). To share puzzles, use Download / Upload. The file format is 81 characters with dots for blanks (one line).</div>
    </div>

    <div>
      <div style="font-weight:700">Difficulty presets</div>
      <div style="margin-top:6px" class="meta">
        Easy/Medium/Hard examples are included as presets. You can also paste/upload puzzles in the 81-char format.
      </div>
    </div>

    <div style="margin-top:auto;display:flex;gap:8px;align-items:center;justify-content:space-between">
      <div class="meta">Saved in browser: <strong id="saveKey">sudoku_progress</strong></div>
      <div style="text-align:right">
        <small class="meta">Made for GitHub Pages</small>
      </div>
    </div>
  </aside>
</div>

<script>
(function(){
  // --- Utilities ---
  const qs = s => document.querySelector(s);
  const qsa = s => Array.from(document.querySelectorAll(s));

  // DOM
  const boardEl = qs('#board');
  const togglePencilBtn = qs('#togglePencil');
  const hintBtn = qs('#hint');
  const checkBtn = qs('#check');
  const clearBtn = qs('#clear');
  const restartBtn = qs('#restart');
  const undoBtn = qs('#undo');
  const presetSel = qs('#preset');
  const progressEl = qs('#progress');
  const statusLabel = qs('#statusLabel');
  const downloadBtn = qs('#download');
  const uploadBtn = qs('#upload');
  const uploadFile = qs('#uploadFile');
  const saveKeyEl = qs('#saveKey');

  // Game state
  const STORAGE_KEY = 'sudoku_progress';
  saveKeyEl.textContent = STORAGE_KEY;
  let given = Array(81).fill(null); // fixed clues
  let cells = Array(81).fill(null); // player's entries (numbers 1-9 or null)
  let pencils = Array(81).fill(null).map(()=> new Set()); // candidate sets
  let selected = 0;
  let pencilMode = false;
  let history = []; // for undo

  // default puzzles (81 char strings, '.' for blank)
  const PUZZLES = {
    default:
      '53..7....6..195... .98....6.8...6...3.4..8.3..1.7...2...6.6....28.419..5....8..79'.replace(/\s+/g,''),
    easy:
      '6....8.9.4....2...8..3..5..1.6...47..5..2..19...8.6..4..6..5...9....8.7.2....1'.replace(/\s+/g,''),
    medium:
      '...26.7.168..7..9.19...45..82.1...4....46.29...5...3.28..93...74..4..5.367.3...'.replace(/\s+/g,''),
    hard:
      '.7.2...6....3.1..1..4..8.6...9.....2.1.8.5.....6...4.5..3..2..6..9.8....3...1.9.'.replace(/\s+/g,'')
  };

  // Create 81 cell elements
  for(let i=0;i<81;i++){
    const el = document.createElement('button');
    el.className = 'cell';
    el.dataset.i = i;
    el.type = 'button';
    el.addEventListener('click', () => selectCell(i));
    el.addEventListener('keydown', (e) => {
      if(e.key >= '1' && e.key <= '9'){ e.preventDefault(); handleNumberInput(Number(e.key)); }
      else if(e.key === 'Backspace' || e.key === 'Delete'){ e.preventDefault(); clearCell(selected); }
      else if(e.key.toLowerCase() === 'p'){ togglePencil(); }
      else if(e.key.toLowerCase() === 'h'){ makeHint(); }
      else if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){ undo(); }
      // Arrow navigation
      else if(e.key === 'ArrowRight'){ e.preventDefault(); selectCell((i%9===8)?i-8:i+1); }
      else if(e.key === 'ArrowLeft'){ e.preventDefault(); selectCell((i%9===0)?i+8:i-1); }
      else if(e.key === 'ArrowDown'){ e.preventDefault(); selectCell((i+9)%81); }
      else if(e.key === 'ArrowUp'){ e.preventDefault(); selectCell((i+72)%81); }
    });
    // pencil container
    const pencil = document.createElement('div');
    pencil.className = 'pencil';
    pencil.style.display='none';
    for(let k=1;k<=9;k++){
      const span = document.createElement('div');
      span.className='p'+k;
      span.textContent = '';
      pencil.appendChild(span);
    }
    el.appendChild(pencil);
    boardEl.appendChild(el);
  }

  // Grab cell elements after insertion
  const cellEls = qsa('.cell');

  // Block borders: apply thicker borders around 3x3 blocks
  function styleBlockBorders(){
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const i = r*9 + c;
        const el = cellEls[i];
        const style = {};
        style.borderTop = (r%3===0) ? '4px solid rgba(2,6,23,0.06)' : '1px solid rgba(2,6,23,0.04)';
        style.borderLeft = (c%3===0) ? '4px solid rgba(2,6,23,0.06)' : '1px solid rgba(2,6,23,0.04)';
        style.borderRight = (c===8) ? '4px solid rgba(2,6,23,0.06)' : '';
        style.borderBottom = (r===8) ? '4px solid rgba(2,6,23,0.06)' : '';
        Object.assign(el.style, style);
      }
    }
  }
  styleBlockBorders();

  // Load puzzle from preset
  function loadPreset(key){
    const s = PUZZLES[key] || PUZZLES['default'];
    if(!s || s.length!==81){ alert('Invalid puzzle preset'); return; }
    given = Array.from(s).map(ch => (ch === '.' ? null : Number(ch)));
    cells = Array(81).fill(null);
    pencils = Array(81).fill(null).map(()=> new Set());
    history = [];
    pencilMode = false;
    togglePencilBtn.textContent = 'Pencil: Off';
    selected = 0;
    saveStateToStorage(key);
    renderAll();
    updateProgress();
    status('Loaded preset: ' + key);
  }

  // Render
  function renderAll(){
    for(let i=0;i<81;i++) renderCell(i);
    highlightRelated(selected);
  }

  function renderCell(i){
    const el = cellEls[i];
    el.classList.toggle('given', !!given[i]);
    el.classList.remove('selected','same-row-col-box','conflict');
    el.innerHTML = ''; // remove children (including pencil) and recreate for clarity
    // create display value or pencil
    const val = cells[i];
    if(val){
      const span = document.createElement('div');
      span.className = 'value';
      span.textContent = val;
      span.style.fontSize = '1.1rem';
      span.style.pointerEvents = 'none';
      el.appendChild(span);
    } else {
      // put pencil container in place
      const pencil = document.createElement('div');
      pencil.className = 'pencil';
      pencil.style.display = pencils[i].size ? 'grid' : 'none';
      for(let k=1;k<=9;k++){
        const span = document.createElement('div');
        span.textContent = pencils[i].has(k) ? k : '';
        pencil.appendChild(span);
      }
      el.appendChild(pencil);
    }
    // if given, overlay the given number (as a different style)
    if(given[i]){
      const span = document.createElement('div');
      span.className = 'value';
      span.textContent = given[i];
      span.style.fontWeight = 800;
      span.style.color = '#0b1320';
      el.appendChild(span);
    }
  }

  // Selection and highlighting
  function selectCell(i){
    if(i<0 || i>80) return;
    selected = i;
    // focus the DOM element for keyboard events
    const el = cellEls[i];
    el.focus();
    highlightRelated(i);
  }

  function highlightRelated(i){
    // remove classes
    cellEls.forEach(c=> c.classList.remove('selected','same-row-col-box'));
    // highlight selected
    cellEls[i].classList.add('selected');
    const r = Math.floor(i/9), c = i%9;
    // same row, col, and box
    for(let j=0;j<81;j++){
      const rr = Math.floor(j/9), cc = j%9;
      const same = (rr===r) || (cc===c) || (Math.floor(rr/3)===Math.floor(r/3) && Math.floor(cc/3)===Math.floor(c/3));
      if(same && j!==i) cellEls[j].classList.add('same-row-col-box');
    }
    validateAndMarkConflicts();
  }

  // Input handling
  function handleNumberInput(n){
    if(given[selected]) { status('Cell is a given, cannot change.'); return; }
    if(pencilMode){
      togglePencilAt(selected,n);
      saveHistory({type:'pencil',i:selected,n});
    } else {
      setCell(selected, n);
      saveHistory({type:'set',i:selected,prev:cells[selected],n});
    }
    renderCell(selected);
    updateProgress();
    validateAndMarkConflicts();
  }

  function setCell(i, n){
    cells[i] = n;
    pencils[i].clear();
  }

  function togglePencilAt(i,n){
    if(cells[i]) return;
    if(pencils[i].has(n)) pencils[i].delete(n);
    else pencils[i].add(n);
    renderCell(i);
  }

  function clearCell(i){
    if(given[i]) { status('Cannot clear a given cell.'); return; }
    const prev = cells[i];
    const prevPencils = new Set(pencils[i]);
    cells[i] = null;
    pencils[i].clear();
    saveHistory({type:'clear',i,prev,prevPencils});
    renderCell(i);
    updateProgress();
    validateAndMarkConflicts();
  }

  // Undo
  function saveHistory(entry){
    history.push(entry);
    if(history.length>200) history.shift();
    saveStateToStorage();
  }
  function undo(){
    const last = history.pop();
    if(!last) { status('Nothing to undo'); return; }
    if(last.type === 'set'){
      cells[last.i] = last.prev === undefined ? null : last.prev;
      renderCell(last.i);
    } else if(last.type === 'clear'){
      cells[last.i] = last.prev;
      pencils[last.i] = new Set(last.prevPencils || []);
      renderCell(last.i);
    } else if(last.type === 'pencil'){
      // toggle pencil back
      if(pencils[last.i].has(last.n)) pencils[last.i].delete(last.n);
      else pencils[last.i].add(last.n);
      renderCell(last.i);
    }
    updateProgress();
    validateAndMarkConflicts();
    saveStateToStorage();
  }

  // Validate and highlight conflicts
  function validateAndMarkConflicts(){
    // clear conflict state
    cellEls.forEach(c=> c.classList.remove('conflict'));
    const conflicts = new Set();
    // check rows, cols, boxes
    for(let i=0;i<81;i++){
      const v = cells[i] || given[i];
      if(!v) continue;
      const r = Math.floor(i/9), c = i%9;
      // row
      for(let cc=0;cc<9;cc++){
        const j = r*9+cc;
        if(j!==i && (cells[j]||given[j]) === v) { conflicts.add(i); conflicts.add(j); }
      }
      // col
      for(let rr=0;rr<9;rr++){
        const j = rr*9 + c;
        if(j!==i && (cells[j]||given[j]) === v) { conflicts.add(i); conflicts.add(j); }
      }
      // box
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let rr=br;rr<br+3;rr++){
        for(let cc=bc;cc<bc+3;cc++){
          const j = rr*9 + cc;
          if(j!==i && (cells[j]||given[j]) === v) { conflicts.add(i); conflicts.add(j); }
        }
      }
    }
    // apply classes
    conflicts.forEach(i => cellEls[i].classList.add('conflict'));
    // win detection
    const allFilled = cellEls.every((_,idx)=> !!given[idx] || !!cells[idx]);
    if(allFilled && conflicts.size===0){
      status('Puzzle complete — well done!');
    }
  }

  // Hint: fill one correct cell (simple approach: find an empty cell and compute its only valid candidate, or fetch solution)
  function makeHint(){
    // Try to find a cell with a single valid candidate
    for(let i=0;i<81;i++){
      if(given[i] || cells[i]) continue;
      const candidates = computeCandidates(i);
      if(candidates.length === 1){
        const n = candidates[0];
        setCell(i,n);
        saveHistory({type:'set',i,prev:null,n});
        renderCell(i);
        updateProgress();
        validateAndMarkConflicts();
        status('Hint applied: placed ' + n + ' at cell ' + (i+1));
        return;
      }
    }
    // fallback: place a cell from a simple solved solution (brute-force solve)
    const solved = solveSudoku(mergeBoard());
    if(solved){
      // find a blank to fill (first blank)
      const idx = solved.findIndex((v,idx) => !(given[idx]||cells[idx]));
      if(idx>=0){
        setCell(idx, solved[idx]);
        saveHistory({type:'set',i:idx,prev:null,n:solved[idx]});
        renderCell(idx);
        updateProgress();
        validateAndMarkConflicts();
        status('Hint applied: placed ' + solved[idx] + ' at cell ' + (idx+1));
        return;
      }
    }
    status('No useful hint found.');
  }

  // Compute candidates for a cell
  function computeCandidates(i){
    const used = new Set();
    const r = Math.floor(i/9), c = i%9;
    for(let cc=0;cc<9;cc++){
      const v = cells[r*9+cc] || given[r*9+cc];
      if(v) used.add(v);
    }
    for(let rr=0;rr<9;rr++){
      const v = cells[rr*9+c] || given[rr*9+c];
      if(v) used.add(v);
    }
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let rr=br;rr<br+3;rr++) for(let cc=bc;cc<bc+3;cc++){
      const v = cells[rr*9+cc] || given[rr*9+cc];
      if(v) used.add(v);
    }
    const cand = [];
    for(let n=1;n<=9;n++) if(!used.has(n)) cand.push(n);
    return cand;
  }

  // Merge board into single array (givens overwritten by player's entries)
  function mergeBoard(){
    return Array.from({length:81}, (_,i)=> cells[i] || given[i] || 0);
  }

  // Simple backtracking solver (returns solved array or null)
  function solveSudoku(arr){
    const board = arr.slice();
    function findEmpty(){
      for(let i=0;i<81;i++) if(!board[i]) return i;
      return -1;
    }
    function isValid(pos, val){
      const r=Math.floor(pos/9), c=pos%9;
      for(let cc=0;cc<9;cc++){
        const j=r*9+cc; if(board[j]===val) return false;
      }
      for(let rr=0;rr<9;rr++){
        const j=rr*9+c; if(board[j]===val) return false;
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for(let rr=br;rr<br+3;rr++) for(let cc=bc;cc<bc+3;cc++){
        const j=rr*9+cc; if(board[j]===val) return false;
      }
      return true;
    }
    function backtrack(){
      const pos = findEmpty();
      if(pos === -1) return true;
      for(let val=1;val<=9;val++){
        if(isValid(pos,val)){
          board[pos]=val;
          if(backtrack()) return true;
          board[pos]=0;
        }
      }
      return false;
    }
    if(backtrack()) return board;
    return null;
  }

  // Save and load state to localStorage
  function saveStateToStorage(presetKey){
    try{
      const payload = {
        given, cells: cells.map(v=> v||0),
        pencils: pencils.map(s => Array.from(s)),
        history,
        preset: presetKey || presetSel.value
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
    }catch(e){ console.warn('Could not save state', e); }
  }

  function loadStateFromStorage(){
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if(!raw) return false;
      const p = JSON.parse(raw);
      if(p && p.given && p.given.length===81){
        given = p.given.map(v => v||null);
        cells = p.cells.map(v => v||null);
        pencils = p.pencils.map(arr => new Set(arr||[]));
        history = p.history || [];
        presetSel.value = p.preset || 'default';
        renderAll();
        updateProgress();
        status('Loaded saved progress');
        return true;
      }
    }catch(e){ console.warn('Load failed', e); }
    return false;
  }

  // Download/Upload puzzle as 81-char string (dots for blanks)
  function downloadPuzzle(){
    const s = (given.map(v => v?String(v):'.')).join('');
    const blob = new Blob([s], {type:'text/plain'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'sudoku-puzzle.txt';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }
  function handleUploadFile(file){
    const reader = new FileReader();
    reader.onload = () => {
      const txt = reader.result.trim();
      if(txt.length===81){
        presetSel.value = 'custom';
        given = Array.from(txt).map(ch => ch === '.' ? null : Number(ch));
        cells = Array(81).fill(null);
        pencils = Array(81).fill(null).map(()=> new Set());
        history = [];
        renderAll();
        updateProgress();
        saveStateToStorage('custom');
        status('Uploaded puzzle loaded');
      } else {
        alert('Uploaded file must contain exactly 81 characters (use "." for blanks).');
      }
    };
    reader.readAsText(file);
  }

  // UI actions
  togglePencilBtn.addEventListener('click', togglePencil);
  hintBtn.addEventListener('click', makeHint);
  checkBtn.addEventListener('click', () => { validateAndMarkConflicts(); status('Validation complete'); });
  clearBtn.addEventListener('click', () => {
    if(!confirm('Clear all player entries (givens stay)?')) return;
    cells = Array(81).fill(null);
    pencils = Array(81).fill(null).map(()=> new Set());
    history = [];
    renderAll();
    updateProgress();
    saveStateToStorage();
  });
  restartBtn.addEventListener('click', () => {
    if(!confirm('Restart puzzle from the original givens? This will clear your progress.')) return;
    const preset = presetSel.value === 'custom' ? 'default' : presetSel.value;
    loadPreset(preset);
  });
  undoBtn.addEventListener('click', undo);
  presetSel.addEventListener('change', () => {
    if(presetSel.value === 'custom'){ status('Custom selected — upload a puzzle file'); return; }
    if(!confirm('Load preset "' + presetSel.value + '"? This will clear current progress.')) { presetSel.value = 'default'; return; }
    loadPreset(presetSel.value);
  });
  downloadBtn.addEventListener('click', downloadPuzzle);
  uploadBtn.addEventListener('click', () => uploadFile.click());
  uploadFile.addEventListener('change', (e) => {
    const f = e.target.files[0];
    if(f) handleUploadFile(f);
    uploadFile.value = '';
  });

  // Toggle pencil
  function togglePencil(){
    pencilMode = !pencilMode;
    togglePencilBtn.textContent = pencilMode ? 'Pencil: On' : 'Pencil: Off';
    status('Pencil ' + (pencilMode ? 'on' : 'off'));
  }

  // Update progress display
  function updateProgress(){
    const filled = cellEls.reduce((acc,el,idx) => acc + ((given[idx]||cells[idx])?1:0), 0);
    progressEl.textContent = 'Filled: ' + filled + ' / 81';
    saveStateToStorage();
  }

  // Status
  function status(msg){
    statusLabel.textContent = msg;
    setTimeout(()=> { if(statusLabel.textContent === msg) statusLabel.textContent = 'Ready'; }, 3000);
  }

  // Merge board & save on beforeunload
  window.addEventListener('beforeunload', () => saveStateToStorage());

  // Mouse numeric keypad UI: allow clicking number by focusing cell then pressing number keys
  // Global number entry using keydown
  window.addEventListener('keydown', (e) => {
    if(document.activeElement && document.activeElement.tagName === 'INPUT') return;
    if(e.key >= '1' && e.key <= '9'){ e.preventDefault(); handleNumberInput(Number(e.key)); }
    else if(e.key === 'Backspace' || e.key === 'Delete'){ e.preventDefault(); clearCell(selected); }
    else if(e.key.toLowerCase() === 'p'){ e.preventDefault(); togglePencil(); }
    else if(e.key.toLowerCase() === 'h'){ e.preventDefault(); makeHint(); }
    else if((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){ e.preventDefault(); undo(); }
  });

  // Initialize: try to load saved state or load default
  if(!loadStateFromStorage()) loadPreset('default');
  renderAll();
  updateProgress();

  // Expose small API functions for potential embedding
  window.sudokuApp = {
    loadPreset,
    downloadPuzzle,
    getState: () => ({given, cells: cells.slice()}),
    solve: () => solveSudoku(mergeBoard())
  };

})();
</script>
</body>
</html>
